SHEET5
#+SETUPFILE: options.org

* TODO
  DEADLINE: <2009-11-25 Mer>

* Exercise 1
** (a) /getText/

#+BEGIN_SRC haskell 
getText :: IO String
getText = do
  x <- getChar
  if x == '\n'
     then
         return ""
     else do
         xs <- getText
         return (x:xs)
#+END_SRC
   
   
** (b) /getInt/
   
#+BEGIN_SRC haskell 
getInt :: IO Int
getInt = do
  n <- getText
  return (read n::Int)
#+END_SRC


** (c) /draw/
   
#+BEGIN_SRC haskell 
draw :: IO ()
draw = do
  putStr "please enter a non-negative number"
  n <- getInt
  mapM_ (\_ ->putStrLn (concat $ replicate n "*")) [1..n]
  -- would be even better using replicateM_ from Control.monad
  -- replicateM_ n (\_ -> put ...)
#+END_SRC

* Exercise 2
  Given the following:

#+BEGIN_SRC haskell 
data MyMaybe a = Value a | Error

instance Monad MyMaybe where
    return = Value
    Error >>= q = Error
    Value x >>= q = q x
    
instance Show a => Show (MyMaybe a) where
    show Error = "an error occurred"
    show (Value x) = show x
#+END_SRC

** (a) Prove the three monad laws for it

*** (1) p >>= return = p

*** (2) return x >>= f = f x
   
*** (3) (p >>= \x -> q) >>= \y - >r = p >>= \x -> (q >>= \y -> r)
    
** (b) Extend the data type Term with logarithm and let eval handle it

#+BEGIN_SRC haskell 
data Term = Con Float | Div Term Term | Log Term

eval :: Term -> MyMaybe Float
eval (Log x) = do
  y <- eval x
  if y <= 0 then Error else return $ log y

eval (Con x) = Value x
eval (Div t u) = do
  x <- eval t
  y <- eval u
  if y /= 0 then return (x/y) else Error
#+END_SRC


** (c)
