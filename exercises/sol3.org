#+SETUPFILE: options.org

* TODO Sheet3
  DEADLINE: <2009-11-11 Mer>
  
* Exercise 1
** (a)
    
#+BEGIN_SRC haskell
    data Polynomials a = Const a | Var String | Sum (Polynomials a) (Polynomials a) | Prod (Polynomials a) (Polynomials a)
#+END_SRC

** (b)
#+BEGIN_SRC haskell
  instance (Show a) => Show (Polynomials a) where
      show (Var x) = x
      show (Const x) = show x
      show (Prod x y) = "(" ++ show x ++ " * " ++ show y ++ ")"
      show (Sum x y) = "(" ++ show x ++ " + " ++ show y ++ ")"
#+END_SRC

** (c)
#+BEGIN_SRC haskell
  class PlusTimes a where
      plus :: a -> a -> a
      times :: a -> a -> a
#+END_SRC

** (d)
#+BEGIN_SRC haskell
  instance PlusTimes Int where
      plus x y = x + y
      times x y = x * y
#+END_SRC

Check if possible to disambiguate when calling for example
*plus 2 3*

** (e)
#+BEGIN_SRC haskell
   data Tropicals = Finite Int | Infinite
   instance Show Tropicals where
         show (Finite x) = show x
         show Infinite = "Infinity"
   
   show $ Finite 10
#+END_SRC

** (f)
#+BEGIN_SRC haskell
   instance PlusTimes Tropicals where
         plus (Finite x) Infinite = Finite x
         plus Infinite (Finite x) = Finite x
         plus (Finite x) (Finite y) = Finite $ min x y

         times (Finite x) Infinite = Infinite
         times Infinite (Finite x) = Infinite
         times (Finite x) (Finite y) = Finite $ x + y
#+END_SRC

** (g)
#+BEGIN_SRC haskell
  class (Ord a, PlusTimes a) => Interpretable a where
    interpret :: Polynomials a -> (String -> a) -> a
    gt :: Polynomials a -> Polynomials a -> (String -> a) -> Bool
    interpret (Var x) m = m x
    interpret (Sum x y) m = plus (interpret x m) (interpret y m)
    interpret (Prod x y) m = times (interpret x m) (interpret y m)
    interpret (Const x) _ = x
    gt polX polY m = (interpret polX m) > (interpret polY m)
#+END_SRC

** (h)
#+BEGIN_SRC haskell
   -- nothing else needed, the implementation in the class always works
   instance Interpretable Int
   instance Interpretable Tropicals
#+END_SRC


* Exercise 2

** (a)

#+BEGIN_SRC haskell
  data Tree a b = Empty | Node a (Tree b a) (Tree b a) deriving Show
  
  mapTree :: (a -> c) -> (b -> d) -> Tree a b -> Tree c d
  mapTree _ _ Empty = Empty
  mapTree f1 f2 (Node x y z) =
          Node (f1 x) (mapTree f2 f1 y) (mapTree f2 f1 z)
#+END_SRC

** (b)
   
#+BEGIN_SRC haskell
  foldTree :: (a -> c -> c -> c) -> (b -> c -> c -> c) -> c -> Tree a b -> c
  -- "foldTree fa fb e t" replaces all occurences of
  foldTree _ _ e Empty = e
  foldTree fa fb e (Node x y z) = fa x (foldTree fb fa e y) (foldTree fb fa e z)
#+END_SRC

** (c)

#+BEGIN_SRC haskell
   
#+END_SRC
