FUNCTIONAL PROGRAMMING

* Exam study
  - [ ] sheet1
  - [ ] sheet2
  - [ ] sheet3
  - 

* Innermost
  call by value

* Outermost
  call by name
** Pros
   Only evaluate subexpressions needed for overall result

** Cons
   Sometimes you have to evaluate more than once some of the expressions

   Haskell uses the so called *lazy evaluation*
   
   Basically outermost evaluation, but keeping memory of *different evaluations*, keeping tracks of duplicates and evaluates them all in parallel.
   
   An example where outermost is better could be
   
#+BEGIN_SRC haskell
   three :: Int -> Int
   three x = 3
   costly :: Int -> Int
   costly x = longcomputation
#+END_SRC

and here *three (costly x)* with innermost would take a very long time but the result is always 3.

We can define functions that work on infinite data structures.

* DECLARATIONS
** Conditional defining equations

#+BEGIN_SRC haskell
  -- you can use tuples here
  maxi :: (Int, Int) -> Int
  maxi (x, y)
  | x >= y = x
  | otherwise = y
#+END_SRC

** Currying

#+BEGIN_SRC haskell
  -- equivalent solution
  plus :: Int -> Int -> Int
  plus :: (Int, Int) -> Int
  plus :: Int -> (Int -> Int) -- takes int and returns another functions
#+END_SRC

  Application always associates *to the left*

  I can define a higher order function
  
#+BEGIN_SRC haskell
  suc :: Int -> Int
  suc = plus 1
#+END_SRC

*** Advantages of currying
    - Apply functions to only one argument

** Pattern matching

The order does matter, the first matching expression will be executed

#+BEGIN_SRC haskell
  und :: Bool -> Bool -> Bool
  und True y = y
  und False y = False
#+END_SRC

*** Pattern matching for different data structures
#+BEGIN_SRC haskell
   Bool -> True | False
   [a] -> [] | a : [a]

   len :: [a] -> Int
   len [] = 0
   len (x:xs) = 1 + len xs
#+END_SRC

#+resname:
: <interactive>:1:11: parse error on input `='

** Pattern declaration
  Assign a unique value to every variable in the pattern.
 
#+BEGIN_SRC haskell
  x1, y1 :: Int
  [x1, y1] = [1,2]
  -- every variable gets an unique value
#+END_SRC
  
** Operators Infix declarations
   2 + 3 \rightarrow infix symbol
   (+) \rightarrow prefix symbol
   
   Fixity can be shifted between prefix/infix.

** Association
   We normally associate to the right, but we can define ourselves where the associativity should go.
   *infixl* *infixr*
   *infix*, associates neither to left or right
   45 `divide` 5 `divide` 3 gives error in this case
   
   - *:* associates to the right, 3:4:[] \rightarrow 3:(4:[])

   - function application associates to the left (square square 3)

** Priority
   We can define a number of priority in infix priority (between 0 and 9 (which is default)).
   *infixl 9 %%*
   *infixl 8 @@*

* Expressions
  First haskell checks the type and IF is well typed than the expression is evaluated.

* Programming with lazy evaluation
  - In general we use leftmost evaluation
  - some pre-defined arithmetical operators require fully evaluated arguments
  - with pattern matching arguments are evaluated until one can decide which to pick

* Monads
  *return :: a -> IO a*
  Does nothing and incapsulates an object of type a.
  
  *(>>) :: IO a -> IO b -> IO b*
  chain something somewhere else.

  For example:
  *getChar >> return ()* takes a character and then ignores it.

  *(>>=) :: Io a -> (a -> IO b) *
  It gives you back another action.

  Getting input from the shell:

#+begin_src haskell
  gets :: Int -> IO String
  gets 0 = return []
  gets (n+1) = getChar >>= \x -> gets n
  -- which can be written much better as
  
  gets = do
    x <- getChar
    xs <- gets
    return (x:xs)
#+end_src

    In general monads are used to separate computations from inside the monads.
  

** Implement a monadic evaluator for terms

#+BEGIN_SRC haskell 
  data Term = Con Float | Div Term Term
  data Value a = Result a
  
  instance Show a => Show (Value a) where
      show (Result x) = "Result: " ++ show x
      
  -- now we instantiate the monad class
  instance Monad Value where
      return = Result
      (Result x) >>= x
      
  -- program eval in such a way using return/bind as much as possible
  eval1 :: Term -> Value Float
  eval1 (Con x) = return x
  eval1 (Div t u) = do
           x <- eval1 t
           y <- eval1 u
           return (Div x y)
  
  eval2 :: Term -> Maybe Float
  eval2 (Con x) = return x
  eval2 (Div t m) = do
    x <- eval2 t
    y <- eval2 u
    if y == 0 then Nothing
    else return (x / y)
#+END_SRC


   


* Theory
** Monotonic function
   
   
** Continuos function
   If $f : D1 -> D2$
   $\bigsqcup f(s) = f(\bigsqcup s)$

** Fix point theorem

* Simple haskell
** Some restrictions
   1. Only one declaration /var = exp/

   2. No predefined lists

   3. Only allow application of expressions in form /expr1 expr2/

   4. No case construct (no pattern matching)

   5. Lambda expressions only with variables instead of arbitrary patterns

   6. No /where/, only /let/

   A simple haskell program is a program without type synomyms and no type classes and no predefined lists.

** Free variable
   - free(_var_) = { _var_ }
   - free(_constr_) = free(_integer_)
   - free(_float_) = free(_char_) = \empty

** 12 Rules to convert complex to simple haskell
*** Def 2.2.11
    Complex H-expression is transformed into exp by applying some rules as long as possible.

    This is the code that you want to transform to simple haskell
#+begin_src haskell
    append Nil z = z
    append (Cons x y) z = Cons x (append y z)
#+end_src

    
**** 1. Transform several flat declarations in 1 pattern declaration.
     var pat1...patn = exp1; ... ; var pat1...patn = exp^k
     
**** 2. Transform lambda expressions with serveral patterns
     \pat1 ... patn -> exp
     \pat1 -> (\pat2 -> (\patn -> exp))
     

**** 3. Lambda expressions with non-variable patterns
     \pat -> exp
     \var -> case var of palth -> exp
     
**** 4. Translation of case to match (for eliminating case expressions)
     case exp of {path1 -> exp1;
                 patn -> exp2}

**** 9. match for non empty tuples
     match (pat1, ... ,patn) exp exp1 exp2
     if this works 

**** 6. match for the joker pattern (_).
     match _ exp exp1 exp2
     _____________________
           exp1

**** 7. match for constructors
     match (constr pat1 patn) exp exp1 exp2
     _____________________________________
             if (isa constr exp)
	         then match (pat1, patn)
                 else exp2
		 

* Lambda calculus and haskell
  Haskell sometimes doesn't need to get the normal form, when reaching a \lambda expression we stop.

* Implementing haskell (def 3.3.6)
  For a complex haskell program with the constructors Con, let \delta be the correspondign \delta-rule.
  Let P the sequence of pattern and function declarations, let _exp_ be a complex haskell-expression where all free variables are predefined or defined in P.
  _Evaluation_ of _exp_ in program P is done by WHNO-reduction with the above \delta-rules + \beta-reduction.

* Theorem 3.3.7 (Correctness of implementation)
  Our interpreter realizes undefinedness by non-termination (also if functions are not completely defined).
  f 1 would not terminate, our interpreter terminates if the value of our expression is not completely undefined.
  

* Confluent relation

* Lambda calculus

** \alpha reduction

** \beta reduction

** \delta reduction
   [[http://delta.reduction.word.sytes.org/][delta reduction]]
   This kind of reduction is not present in *pure* lambda calculus.
   A set \delta of rules of the form
   ct1...tn → r with c \in C,t1,...,tn, r \in \gamma is called a 
   delta-rule set if
   (1) t1, . . . , tn, r are closed lambda terms
   (2) all ti are in \beta-normal form
   (3) the ti do not contain any left-hand side of a rule from \delta
   (4) in \delta the r exist no two rules c t1...tn → randct1...tm → r′ with m >= n.
   
   
