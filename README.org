Different strategies of evaluation

* Innermost
  call by value

* Outermost
  call by name

** Pros
   Only evaluate subexpressions needed for overall result

** Cons
   Sometimes you have to evaluate more than once some of the expressions


Haskell uses the so called *lazy evaluation*

Basically outermost evaluation, but keeping memory of *different evaluations*, keeping tracks of duplicates and evaluates them all in parallel.

An example where outermost is better could be

#+BEGIN_SRC haskell
three :: Int -> Int
three x = 3
costly :: Int -> Int
costly x = longcomputation
#+END_SRC

and here *three (costly x)* with innermost would take a very long time but the result is always 3.

We can define functions that work on infinite data structures.


* Conditional defining equations

#+BEGIN_SRC haskell
  -- you can use tuples here
  maxi :: (Int, Int) -> Int
  maxi (x, y)
  | x >= y = x
  | otherwise = y
#+END_SRC


* Currying

#+BEGIN_SRC haskell
  -- equivalent solution
  plus :: Int -> Int -> Int
  plus :: (Int, Int) -> Int
  plus :: Int -> (Int -> Int) -- takes int and returns another functions
#+END_SRC

  Application always associates *to the left*

  I can define a higher order function
  
#+BEGIN_SRC haskell
  suc :: Int -> Int
  suc = plus 1
#+END_SRC

** Advantages of currying
   - Apply functions to only one argument


* Pattern matching

The order does matter, the first matching expression will be executed

#+BEGIN_SRC haskell
  und :: Bool -> Bool -> Bool
  und True y = y
  und False y = False
#+END_SRC

** Pattern matching for different data structures
#+BEGIN_SRC haskell
   Bool -> True | False
   [a] -> [] | a : [a]

   len :: [a] -> Int
   len [] = 0
   len (x:xs) = 1 + len xs
#+END_SRC

#+resname:
: <interactive>:1:11: parse error on input `='

* Pattern declaration
  Assign a unique value to every variable in the pattern.
 
#+BEGIN_SRC haskell
  x1, y1 :: Int
  [x1, y1] = [1,2]
  -- every variable gets an unique value
#+END_SRC
  

* Operators Infix declarations
  2 + 3 \rightarrow infix symbol
  (+) \rightarrow prefix symbol
  
  Fixity can be shifted between prefix/infix.

* Association
  We normally associate to the right, but we can define ourselves where the associativity should go.
  *infixl* *infixr*
  *infix*, associates neither to left or right
  45 `divide` 5 `divide` 3 gives error in this case
  
  - *:* associates to the right, 3:4:[] \rightarrow 3:(4:[])

  - function application associates to the left (square square 3)
